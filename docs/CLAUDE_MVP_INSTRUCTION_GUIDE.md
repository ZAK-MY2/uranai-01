# Claude MVP段階開発 指示ガイド

## 🎯 基本原則

### 1. 32K tokens制限の厳守
```
✅ 良い例：
「認証機能の型定義とスキーマだけ作って」
→ 5-10ファイル、15K tokens以内

❌ 悪い例：
「認証システム全体を実装して」
→ 20-30ファイル、50K tokens超過
```

### 2. 段階的完結性の確保
```
各段階 = 独立して動作確認可能な単位
次段階 = 前段階の成果物を前提に構築
```

## 📋 効果的な指示パターン

### パターン1: 層別実装指示
```markdown
## Stage 1: データ層
「Supabaseのスキーマと型定義だけ作って。
対象: /types/database.ts, /lib/supabase/schema.sql
完了条件: 型定義が完成してエラーなし」

## Stage 2: API層  
「Stage 1の型を使ってAPIエンドポイントを実装。
対象: /app/api/*/route.ts
完了条件: 各エンドポイントが独立して動作」

## Stage 3: UI層
「Stage 2のAPIを使ってUIコンポーネントを実装。
対象: /components/*, /app/*/page.tsx
完了条件: 画面が表示されてAPIと連携」
```

### パターン2: 機能別実装指示
```markdown
## Feature 1: ユーザー管理
「ユーザー登録・ログイン機能を完結実装。
含む: スキーマ、API、UI、エラーハンドリング
除外: 他機能との連携部分
完了条件: ユーザーが登録・ログインできる」

## Feature 2: コンテンツ管理
「記事のCRUD機能を完結実装。
前提: Feature 1のユーザー認証を利用
含む: 記事テーブル、API、管理画面
完了条件: 記事の作成・編集・削除が可能」
```

## 🚀 実践的な指示例

### 良い指示例（明確な境界）
```
1. 「占い結果の型定義とデータ構造を設計して」
   → 明確な範囲、小さなコンテキスト

2. 「型定義を使って占い計算ロジックだけ実装」
   → 前段階を参照、ロジックに集中

3. 「計算ロジックを使って結果表示UIを作成」
   → 統合は最小限、UIに集中

4. 「全体を統合してエラーハンドリング追加」
   → 最終調整のみ
```

### 悪い指示例（曖昧な境界）
```
❌ 「占いアプリを作って」
   → 範囲が広すぎる、コンテキスト爆発

❌ 「いい感じに実装して」
   → 境界が不明確、推測が必要

❌ 「全機能を並列で実装」
   → 32K tokens確実に超過
```

## 📊 段階サイズの目安

| 段階タイプ | ファイル数 | tokens目安 | 作業時間 |
|-----------|------------|------------|----------|
| 型定義 | 3-5個 | 5-10K | 20-30分 |
| ロジック実装 | 5-8個 | 15-20K | 30-45分 |
| UI実装 | 4-6個 | 10-15K | 30-40分 |
| 統合・調整 | 2-3個 | 5-8K | 15-20分 |

## 🔄 段階間の情報引き継ぎ

### 必要最小限の参照
```markdown
「前段階で作った User 型を使って、
ユーザープロフィール表示コンポーネントを実装。
参照: /types/user.ts のみ
新規作成: /components/UserProfile.tsx」
```

### コンテキストリセット活用
```markdown
「ここまでの実装は完了。
次は新しいタスクとして、通知機能を追加。
既存コードは触らず、新規ファイルのみ作成」
```

## ⚡ 高速化テクニック

### 1. 並列可能タスクの識別
```markdown
「以下を独立して実装（相互依存なし）：
- 利用規約ページ（静的）
- プライバシーポリシー（静的）
- お問い合わせフォーム（独立機能）」
```

### 2. テンプレート活用
```markdown
「UserListコンポーネントと同じパターンで
ArticleListコンポーネントを作成」
```

### 3. 明確な完了条件
```markdown
「完了条件：
✓ TypeScriptエラーなし
✓ npm run buildが成功
✓ 基本的な表示確認OK」
```

## 🚨 注意事項

### コンテキスト管理
- 各段階で参照する既存ファイルを明示
- 不要な過去情報は含めない
- 「全体を見て」という指示は避ける

### エラー対処
- エラー時は該当箇所のみ修正
- 全体再実装は避ける
- 段階的な問題切り分け

### 品質確保
- 各段階でlint/型チェック実行
- 動作確認してから次段階へ
- 手戻りを最小化

## 📚 実例：URANAI-01の成功パターン

```markdown
指示1: 「九星気学の型定義を作成」
→ 5ファイル、8K tokens、20分

指示2: 「型を使って計算ロジック実装」  
→ 6ファイル、15K tokens、30分

指示3: 「ロジックを使って結果表示UI作成」
→ 4ファイル、12K tokens、25分

指示4: 「全体統合とエラーハンドリング」
→ 3ファイル、8K tokens、15分

合計: 18ファイル、43K tokens、90分
（一括なら100K tokens超えて失敗）
```

## 🎯 まとめ

**成功の鍵**: 
- 明確な境界設定
- 32K tokens制限の厳守
- 段階的完結性の確保
- 最小限の参照関係

**Claude自律開発を最大化する指示方法です**